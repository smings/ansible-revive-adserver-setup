---
- name: "Checking if we run on a Jenkins server or not. Delegating this task to localhost"
  delegate_to: 127.0.0.1
  shell: if [ -z $JENKINS_URL ]; then echo "non_jenkins_execution"; else echo $JENKINS_URL;  fi | {{ jenkins.url_sed }}
  register: jenkins_context

  # Installs the core webapp on webapp appservers, or as FirstSpirit preview on a FirstSpirit server

  # Expecting an already installed Java11 JVM
  # JVM path can be set as host or group var. See webapp.service.j2

- name: "Block that gets only executed on all Jenkins servers"
  block:

    - name: "Creating atifact directories if they don't exist yet"
      become: yes
      delegate_to: 127.0.0.1
      file:
        path: "{{ item }}"
        state: directory
        mode: '0755'
        owner: "{{ jenkins[jenkins_context.stdout].owner }}"
        group: "{{ jenkins[jenkins_context.stdout].group }}"
      with_items:
        - "{{ jenkins[jenkins_context.stdout].artifact_directories.webapp_dir }}"

    - name: "(Debian) Making sure that the package 'python-lxml' is available when run on a Jenkins server"
      become: yes
      delegate_to: 127.0.0.1
      apt:
        name: python-lxml
        state: latest
      when: ansible_facts['distribution'] == "Debian"

    - name: "(CentOS) Making sure that the package 'python-lxml' is available when run on a Jenkins server"
      become: yes
      delegate_to: 127.0.0.1
      vars:
        ansible_python_interpreter: "{{ ansible_python2_interpreter }}"
      yum:
        name: python-lxml
        state: latest
      when: ansible_facts['distribution'] == "CentOS"

    - name: "Retrieving latest 'webapp' artifact from Nexus {{ jenkins[jenkins_context.stdout].repository_url }} with group_id "
      become: yes
      delegate_to: 127.0.0.1
      # vars:
      #   ansible_python_interpreter: /usr/bin/python
      maven_artifact:
        group_id: "{{ jenkins[jenkins_context.stdout].group_id }}"
        artifact_id: webapp
        repository_url: "{{ jenkins[jenkins_context.stdout].repository_url }}"
        username: "{{ nexus_user }}"
        password: "{{ nexus_password }}"
        dest: "{{ jenkins[jenkins_context.stdout].artifact_directories.webapp_dir }}"
        validate_certs: no
        verify_checksum: always
        mode: '0644'

    - name: "Copying the latest 'webapp' artifact from Jenkins to remote /tmp folder"
      become: yes
      copy:
        src: "{{ jenkins[jenkins_context.stdout].artifact_directories.webapp_dir }}/{{ webapp.jar_nexus_file_name }}"
        dest: "/tmp/{{ webapp.jar_file_name }}"
        owner: "{{ hostvars[inventory_hostname].app_user }}"

  when: jenkins_context.stdout != "non_jenkins_execution"
# / "Block that gets only executed on all Jenkins servers"


- name: "Block for non-Jenkins servers"
  block:

  - name: "Checking if local '{{ webapp.jar_file_directory }}' exists="
    delegate_to: 127.0.0.1
    stat:
      path: "{{ webapp.jar_file_directory }}"
    register: target_directory

  - name: "Checking if there are any files in the target directory, that need to be copied"
    delegate_to: 127.0.0.1
    find:
      paths:
        - "{{ webapp.jar_file_directory }}"
      patterns:
        - "{{ webapp.jar_file_pattern }}"
    register: jar_files_found
    when: target_directory.stat.exists and target_directory.stat.isdir

  - name: "If not run on Jenkins server and no local jar file exists, we have to fail here"
    fail:
      msg: "Couldn't find local jar files in '{{ webapp.jar_file_directory }}' matching '{{ webapp.jar_file_pattern }}' -> Aborting!"
    when: jar_files_found.matched == 0

  - name: "Copying 'webapp' artifact from local target folder to remote /tmp folder"
    become: yes
    copy:
      src: "{{ item }}"
      dest: "/tmp/{{ webapp.jar_file_name }}"
      owner: "{{ hostvars[inventory_hostname].app_user }}"
    with_fileglob:
      - "{{ webapp.jar_file_directory }}/{{ webapp.jar_file_pattern }}"

  when: jenkins_context.stdout == "non_jenkins_execution"
# / "Block for non-Jenkins servers"

- name: "Adding webapp user {{ hostvars[inventory_hostname].app_user }}"
  become: yes
  user:
    name: "{{ hostvars[inventory_hostname].app_user }}"

- name: "Stopping the webapp service. If not yet present, we ignore errors"
  become: yes
  systemd:
    name: webapp
    state: stopped
  ignore_errors: yes

- name: "Installing webapp service as systemd service"
  become: yes
  template:
    src: webapp.service.j2
    dest: /etc/systemd/system/webapp.service

- name: "Creating base directory {{ webapp[jenkins_context.stdout].base_directory }} for webapp"
  become: yes
  file:
    path: "{{ webapp[jenkins_context.stdout].base_directory }}"
    state: directory
    owner: "{{ hostvars[inventory_hostname].app_user }}"

- name: "Creating content directory {{ webapp[jenkins_context.stdout].content_path }} for webapp"
  when: "'firstSpirit' not in group_names"
  become: yes
  file:
    path: "{{ webapp.content_path }}"
    state: directory
    owner: "{{ hostvars[inventory_hostname].app_user }}"

- name: "Copying the 'webapp' jar file from remote /tmp folder to {{ webapp[jenkins_context.stdout].base_directory }}"
  become: yes
  copy:
    remote_src: yes
    src: "/tmp/{{ webapp.jar_file_name }}"
    dest: "{{ webapp[jenkins_context.stdout].base_directory }}/{{ webapp.jar_file_name }}"
    owner: "{{ hostvars[inventory_hostname].app_user }}"

- name: "Starting up webapp service with systemd"
  become: yes
  systemd:
    name: webapp
    daemon_reload: yes
    enabled: yes
    state: started

- name: "Wait for webapp port to open"
  wait_for:
    port: "{{ webapp[jenkins_context.stdout].port }}"
    timeout: "{{ webapp[jenkins_context.stdout].wait_for_port_timeout }}"
  # when: not inventory_hostname is regex("_vm")

- name: "Checking http health endpoint"
  uri:
    url: "http://127.0.0.1:8081/application/internal/health"
    timeout: 60
  # when: not inventory_hostname is regex("_vm")
