---

- name: "Checking if we run on a Jenkins server or not. Delegating this task to localhost"
  delegate_to: 127.0.0.1
  shell: if [ -z $JENKINS_URL ]; then echo "non_jenkins_execution"; else echo $JENKINS_URL;  fi | {{ jenkins.url_sed }}
  register: jenkins_context

- name: "Block that gets only executed on all Jenkins servers"
  block:

    - name: "Creating atifact directories if they don't exist yet"
      become: yes
      delegate_to: 127.0.0.1
      file:
        path: "{{ item }}"
        state: directory
        mode: '0755'
        owner: "{{ jenkins[jenkins_context.stdout].owner }}"
        group: "{{ jenkins[jenkins_context.stdout].group }}"
      with_items:
        - "{{ jenkins[jenkins_context.stdout].artifact_directories.gateway_dir }}"

    - name: "(Debian) Making sure that the package 'python-lxml' is available when run on a Jenkins server"
      become: yes
      delegate_to: 127.0.0.1
      apt:
        name: python-lxml
        state: latest
      when: ansible_facts['distribution'] == "Debian"

    - name: "(CentOS) Making sure that the package 'python-lxml' is available when run on a Jenkins server"
      become: yes
      delegate_to: 127.0.0.1
      vars:
        ansible_python_interpreter: "{{ ansible_python2_interpreter }}"
      yum:
        name: python-lxml
        state: latest
      when: ansible_facts['distribution'] == "CentOS"

    - name: "Retrieving latest 'gateway' artifact from Nexus {{ jenkins[jenkins_context.stdout].repository_url }} with group_id "
      become: yes
      delegate_to: 127.0.0.1
      maven_artifact:
        group_id: "{{ jenkins[jenkins_context.stdout].group_id }}"
        artifact_id: gateway
        repository_url: "{{ jenkins[jenkins_context.stdout].repository_url }}"
        username: "{{ nexus_user }}"
        password: "{{ nexus_password }}"
        dest: "{{ jenkins[jenkins_context.stdout].artifact_directories.gateway_dir }}"
        validate_certs: no
        verify_checksum: always
        mode: '0644'

    - name: "Copying the latest 'gateway' artifact from Jenkins to remote /tmp folder" 
      become: yes
      copy:
        src: "{{ jenkins[jenkins_context.stdout].artifact_directories.gateway_dir }}/{{ gateway_webapp.jar_nexus_file_name }}"
        dest: "/tmp/{{ gateway_webapp.jar_file_name }}"
        owner: "{{ hostvars[inventory_hostname].app_user }}"

  when: jenkins_context.stdout != "non_jenkins_execution"
# / "Block that gets only executed on all Jenkins servers"

- name: "Block for non-Jenkins servers"
  block:

  - name: "Checking if local '{{ gateway_webapp.jar_file_directory }}' exists="
    delegate_to: 127.0.0.1
    stat:
      path: "{{ gateway_webapp.jar_file_directory }}"
    register: target_directory

  - name: "Checking if there are any files in the target directory, that need to be copied"
    delegate_to: 127.0.0.1
    find:
      paths:
        - "{{ gateway_webapp.jar_file_directory }}"
      patterns:
        - "{{ gateway_webapp.jar_file_pattern }}"
    register: jar_files_found
    when: target_directory.stat.exists and target_directory.stat.isdir

  - name: "If not run on Jenkins server and no local jar file exists, we have to fail here"
    fail:
      msg: "Couldn't find local jar files in '{{ gateway_webapp.jar_file_directory }}' matching '{{ gateway_webapp.jar_file_pattern }}' -> Aborting!"
    when: jar_files_found.matched == 0

  - name: "Copying 'gateway' artifact from local target folder to remote /tmp-= folder"
    become: yes
    copy:
      src: "{{ item }}"
      dest: "/tmp/{{ gateway_webapp.jar_file_name }}"
      owner: "{{ hostvars[inventory_hostname].app_user }}"
    with_fileglob:
      - "{{ gateway_webapp.jar_file_directory }}/{{ gateway_webapp.jar_file_pattern }}"

  when: jenkins_context.stdout == "non_jenkins_execution"
# / "Block for non-Jenkins servers"


- name: "Adding webapp user {{ hostvars[inventory_hostname].app_user }}"
  become: yes
  user:
    name: "{{ hostvars[inventory_hostname].app_user }}"

- name: "Stopping the gateway service. If not yet present, we ignore errors"
  become: yes
  systemd:
    name: gateway
    state: stopped
  ignore_errors: yes

- name: "Installing gateway service as systemd service"
  become: yes
  template:
    src: gateway.service.j2
    dest: /etc/systemd/system/gateway.service

- name: "Creating base directory {{ gateway_webapp[jenkins_context.stdout].base_directory }} for edge/gateway webapp "
  become: yes
  file:
    path: "{{ gateway_webapp[jenkins_context.stdout].base_directory }}"
    state: directory
    owner: "{{ hostvars[inventory_hostname].app_user }}"

- name: "Copying the 'gateway' jar file from remote /tmp/ folder to {{ gateway_webapp[jenkins_context.stdout].base_directory }}"
  become: yes
  copy:
    remote_src: yes
    src: "/tmp/{{ gateway_webapp.jar_file_name }}"
    dest: "{{ gateway_webapp[jenkins_context.stdout].base_directory }}/{{ gateway_webapp.jar_file_name }}"
    owner: "{{ hostvars[inventory_hostname].app_user }}"

- name: "Starting up gateway service with systemd"
  become: yes
  systemd:
    name: gateway
    daemon_reload: yes
    enabled: yes
    state: started

- name: "Waiting for gateway port to open"
  wait_for:
    port: "{{ gateway_webapp[jenkins_context.stdout].port }}"
    timeout: "{{ gateway_webapp[jenkins_context.stdout].wait_for_port_timeout }}"

- name: "Checking http health endpoint"
  uri:
    url: "http://127.0.0.1:8080/application/internal/health"
    timeout: "{{ gateway_webapp[jenkins_context.stdout].wait_for_endpoint_timeout }}"
